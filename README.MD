## Laboratorio Sistemas Operativos 2 ##

### PRACTICA 1 ###

### **Nombre:** Edwin Sandoval Lopez
### **Carne:** 202010856  

**Implementaci贸n del Syscall `capture_memory_snapshot`:**


**Introducci贸n y Objetivos del Proyecto:**  
   - **Objetivos generales:** Este proyecto desaf铆a a los estudiantes a personalizar y expandir el kernel de Linux, permiti茅ndoles
      modificar su comportamiento y agregar nuevas funcionalidades. Involucra la configuraci贸n de un
      entorno de desarrollo adecuado para la compilaci贸n del kernel, la implementaci贸n de cambios
      personalizados en el sistema y el desarrollo de m贸dulos que a帽aden llamadas al sistema.

   - **Objetivos espec铆ficos:** 
     - Configurar un entorno de desarrollo para el kernel.  
     - Personalizar el nombre del sistema y agregar mensajes de inicio.  
          - Implementar tres nuevas syscalls personalizadas (`capture_memory_snapshot`, `track_syscall_usage`, `get_io_throttle`).  
     - Desarrollar m贸dulos para obtener estad铆sticas del sistema (CPU, memoria, almacenamiento).

**Configuraci贸n del Entorno:**  
    1) Descargar el kernel de kernel.org (linux-6.8.tar.xz)
    2)Descomprimirlo
    3) Instalar las dependencias
    sudo apt-get install build-essential libncurses5-dev fakeroot wget bzip2 openssl
    sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev

    A partir de aca, en el directorio del codigo fuente. Estando como usuario root con "sudo -s"

    4) Copiar el archivo de config por primera vez
    cp -v /boot/config-$(uname -r) .config

    5) Limpiar el ambiente de compilacion
    make clean

    5.5) Modificar la version del kernel en el archivo Makefile que esta en la raiz

    Hasta arriba, estara asi:

    EXTRAVERSION = 
    EXTRAVERSION = -49-usac1


    6) Ejecutar los config iniciales:
    make oldconfig

    Darle enter a todo
    7) make localmodconfig

    8)Deshabilitar los certificados de firma oficiales de Cannonical:

    scripts/config --disable SYSTEM_TRUSTED_KEYS
    scripts/config --disable SYSTEM_REVOCATION_KEYS


    9)Ahora te podes guiar del script "compile_and_install.sh" para compilar e instalar
    Lo copias con nana, bloc de notas o como prefiras
    Lo marcas con "chmod +x compile_and_install.sh" para permitir que se ejecute
    ./compile_and_install.sh

    Le das que no a todo lo de config (le podes dar enter por defecto)

    10)vas por un cafe en lo que se compila


    11) Le das que si a todos los comandos que te pregunte de install
    Los hace automatico, pero si lo queres hacer manualmente:
    make modules_install
    make install
    make headers_install

**Descripci贸n de Modificaciones en el Kernel:**  
   - **Personalizaci贸n del nombre:** 
      En `/include/linux/uts.h` editar la funci貌n  start_kernel(), 
      ```c
        #define UTS_SYSNAME "Usac Linux - 202010856"
      ```
   - **Personalizaci贸n del mensajes de inicio:** 
      En `/init/main.c` editar la funci貌n  start_kernel(), 
      ```c
          void start_kernel(void)
          {
          //codigo
          	printk("******************************************************\n");
            printk("*                                                    *\n");
            printk("*  Bienvenido al Kernel de Edwin - Versi贸n 1.0       *\n");
            printk("*  Donde la personalizaci贸n se encuentra con la      *\n");
            printk("*  potencia del sistema Linux. 隆A programar!       *\n");
            printk("*                                                    *\n");
            printk("******************************************************\n");
          //codigo 
          }
      ```
## Compilar el kernel

``` bash
 sudo make -j$(nproc)
```
```bash
$ sudo make modules_install
```

```bash
$ sudo make install
```

```bash
$ sudo reboot
```
## Verificacion de los cambios del Kernel

```bash
$ uname -rs
```

```bash
 $ dmesg | grep "Bienvenido"
 ```
![alt text](image.png)
---
# Llamadas al sistema

Para agregar la syscall `capture_memory_snapshot`, primero se seleccion贸 un n煤mero de syscall no utilizado (ej. 462) y se actualiz贸 el archivo `arch/x86/entry/syscalls/syscall_64.tbl` agregando una l铆nea como:

```
462    64    capture_memory_snapshot    sys_capture_memory_snapshot
```

Posteriormente, se implement贸 la funci贸n `SYSCALL_DEFINE` correspondiente en el c贸digo del kernel (por ejemplo en `kernel/capture_snapshot.c`).


Para instalar la nueva syscall en el kernel:

1. **Actualizaci贸n de la Tabla de Syscalls:**  
   Se edit贸 `syscall_64.tbl` para asignar el n煤mero de syscall a `capture_memory_snapshot`.

2. **Definici贸n de la Syscall en el C贸digo del Kernel:**  
   Se cre贸 la funci贸n `SYSCALL_DEFINE` que implementa la l贸gica de `capture_memory_snapshot`.  
   Retorna 0 en caso de 茅xito, o un valor negativo si hay error (por ejemplo, si user_snap apunta a memoria no v谩lida).

3. **Compilaci贸n e Integraci贸n con el Kernel:**  
   El archivo `capture_snapshot.c` se incluy贸 en el `Makefile` del kernel (ej. `obj-y += capture_snapshot.o`) y se recompil贸 el kernel. Tras reiniciar con el nuevo kernel, la syscall qued贸 disponible para su uso en espacio de usuario.


**Implementaci贸n del Syscall `track_syscall_usage`:**

Para agregar la syscall `track_syscall_usage`, primero se seleccion贸 un n煤mero de syscall no utilizado (ej. 463) y se actualiz贸 el archivo `arch/x86/entry/syscalls/syscall_64.tbl` agregando una l铆nea como:

```
463    64    track_syscall_usage    sys_track_syscall_usage
```

Posteriormente, se implement贸 la funci贸n `SYSCALL_DEFINE` correspondiente en el c贸digo del kernel (por ejemplo en `kernel/track_usage.c`). Esta funci贸n recibe un buffer y un tama帽o, y copia al espacio de usuario la informaci贸n recopilada sobre el uso de las syscalls interceptadas.

Para instalar la nueva syscall en el kernel:

1. **Actualizaci贸n de la Tabla de Syscalls:**  
   Se edit贸 `syscall_64.tbl` para asignar el n煤mero de syscall a `track_syscall_usage`.

2. **Definici贸n de la Syscall en el C贸digo del Kernel:**  
   Se cre贸 la funci贸n `SYSCALL_DEFINE` que implementa la l贸gica de `track_syscall_usage`.  
   Esta funci贸n se encarga de devolver un arreglo de estructuras con informaci贸n sobre las syscalls monitoreadas (por ejemplo, `open`, `read`, `write`, `fork`): contador de invocaciones y 煤ltimo timestamp.

3. **Compilaci贸n e Integraci贸n con el Kernel:**  
   El archivo `track_usage.c` se incluy贸 en el `Makefile` del kernel (ej. `obj-y += track_usage.o`) y se recompil贸 el kernel. Tras reiniciar con el nuevo kernel, la syscall qued贸 disponible para su uso en espacio de usuario.

Una vez instalada la syscall, un programa en espacio de usuario puede invocarla mediante `syscall(464, info, size)`, obteniendo as铆 los datos recolectados. Este proceso de agregar la syscall se emplear谩 igualmente para los otros dos syscalls personalizados del proyecto, siguiendo el mismo procedimiento: elegir un n煤mero libre, actualizar `syscall_64.tbl`, implementar la funci贸n `SYSCALL_DEFINE` con su l贸gica espec铆fica, recompilar el kernel e iniciar con 茅l.


---

**Secciones del C贸digo:**
  ```c
  #include <linux/kernel.h>
  #include <linux/syscalls.h>
  #include <linux/timekeeping.h>
  #include <linux/module.h>
  #include <linux/init.h>
  #include <linux/spinlock.h>
  #include <linux/uaccess.h>
  #include <linux/string.h>
  ```

  Estas incluyen las funciones y tipos necesarios para:
  - Definir syscalls.
  - Trabajar con tiempo (nanosegundos).
  - Gestionar sincronizaci贸n por spinlocks.
  - Acceder a funciones espec铆ficas del kernel y estructuras b谩sicas.
  
- **Declaraci贸n de la Tabla de Syscalls:**
  ```c
  extern void* sys_call_table[];
  ```

  Este puntero externo hace referencia a la tabla de llamadas al sistema que se modificar谩 para interceptar las syscalls.  
  *(En la implementaci贸n real, la obtenci贸n de `sys_call_table` puede requerir t茅cnicas adicionales.)*

- **Definici贸n de Estructuras:**
  ```c
  struct my_tracked_syscall_info {
      const char *name;               // Nombre simb贸lico de la syscall
      unsigned long count;            // Conteo de invocaciones
      u64 last_timestamp_ns;          // ltimo timestamp en nanosegundos
      asmlinkage long (*original)(const struct pt_regs *); // Puntero a la funci贸n original
  };
  ```

  Esta estructura almacena informaci贸n acerca de cada syscall monitoreada.

- **Arreglo de Syscalls Monitoreadas:**
  ```c
  static struct my_tracked_syscall_info monitored_syscalls[] = {
      { .name = "open",  .count = 0, .last_timestamp_ns = 0, .original = NULL },
      { .name = "read",  .count = 0, .last_timestamp_ns = 0, .original = NULL },
      { .name = "write", .count = 0, .last_timestamp_ns = 0, .original = NULL },
      { .name = "fork",  .count = 0, .last_timestamp_ns = 0, .original = NULL }
  };
  static int monitored_count = 4;
  ```
  
  Aqu铆 se listan las syscalls a interceptar. `monitored_count` indica cu谩ntas se est谩n rastreando.

- **Spinlock para Sincronizaci贸n:**
  ```c
  static DEFINE_SPINLOCK(syscall_usage_lock);
  ```

  Este lock protege el acceso a las estructuras contadoras, evitando condiciones de carrera cuando m煤ltiples CPUs actualizan las estad铆sticas simult谩neamente.

- **Wrappers de Syscalls Interceptadas:**
  Cada syscall interceptada tiene un wrapper que:
  1. Obtiene el timestamp actual.
  2. Incrementa el contador y actualiza el timestamp en la estructura correspondiente.
  3. Llama a la funci贸n original para no alterar el comportamiento del sistema.
  
  Ejemplo para `read`:
  ```c
  static asmlinkage long hooked_read(const struct pt_regs *regs) {
      long ret;
      u64 now = ktime_get_ns();
      unsigned long flags;

      spin_lock_irqsave(&syscall_usage_lock, flags);
      monitored_syscalls[1].count++;
      monitored_syscalls[1].last_timestamp_ns = now;
      spin_unlock_irqrestore(&syscall_usage_lock, flags);

      ret = monitored_syscalls[1].original(regs);
      return ret;
  }
  ```
  
  Se implementan wrappers similares para `open`, `write` y `fork`.

- **Modificaci贸n de la sys_call_table:**
  Antes de escribir en la `sys_call_table`, se deshabilita la protecci贸n de s贸lo lectura, se guardan los punteros originales, se escriben las nuevas direcciones de las funciones wrapper, y luego se restaura la protecci贸n de la tabla.

  ```c
  // Ejemplo: sys_call_table[__NR_read] = (void*)hooked_read;
  ```

- **Nueva Syscall: `track_syscall_usage`:**
  Esta syscall se define utilizando `SYSCALL_DEFINE`:
  ```c
  struct syscall_usage_user {
      char name[16];
      unsigned long count;
      unsigned long long last_timestamp_ns;
  };

  SYSCALL_DEFINE2(track_syscall_usage, struct syscall_usage_user __user *, buf, int, size) {
      int i;
      unsigned long flags;

      // Verifica que el buffer en el espacio de usuario sea suficiente
      if (size < monitored_count)
          return -EINVAL;

      spin_lock_irqsave(&syscall_usage_lock, flags);
      for (i = 0; i < monitored_count; i++) {
          struct syscall_usage_user temp;
          strncpy(temp.name, monitored_syscalls[i].name, sizeof(temp.name));
          temp.count = monitored_syscalls[i].count;
          temp.last_timestamp_ns = monitored_syscalls[i].last_timestamp_ns;

          if (copy_to_user(&buf[i], &temp, sizeof(temp))) {
              spin_unlock_irqrestore(&syscall_usage_lock, flags);
              return -EFAULT;
          }
      }
      spin_unlock_irqrestore(&syscall_usage_lock, flags);

      return monitored_count;
  }
  ```

---
**Implementaci贸n del Syscall `get_io_throttle`:**

Para agregar la syscall `capture_memory_snapshot`, primero se seleccion贸 un n煤mero de syscall no utilizado (ej. 464) y se actualiz贸 el archivo `arch/x86/entry/syscalls/syscall_64.tbl` agregando una l铆nea como:

```
464    64    capture_memory_snapshot    sys_capture_memory_snapshot
```

Posteriormente, se implement贸 la funci贸n `SYSCALL_DEFINE` correspondiente en el c贸digo del kernel (por ejemplo en `kernel/get_io_throttle.c`).


Para instalar la nueva syscall en el kernel:

1. **Actualizaci贸n de la Tabla de Syscalls:**  
   Se edit贸 `syscall_64.tbl` para asignar el n煤mero de syscall a `get_io_throttle`.

2. **Definici贸n de la Syscall en el C贸digo del Kernel:**  
   Se cre贸 la funci贸n `SYSCALL_DEFINE` que implementa la l贸gica de `get_io_throttle`.  
   Retorna 0 en caso de 茅xito, o un valor negativo si hay error (por ejemplo, si user_snap apunta a memoria no v谩lida).

3. **Compilaci贸n e Integraci贸n con el Kernel:**  
   El archivo `get_io_throttle.c` se incluy贸 en el `Makefile` del kernel (ej. `obj-y += get_io_throttle.o`) y se recompil贸 el kernel. Tras reiniciar con el nuevo kernel, la syscall qued贸 disponible para su uso en espacio de usuario.

```c
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/pid.h>
#include <linux/sched.h>
#include <linux/sched/signal.h>
#include <linux/types.h>

struct io_stats_user {
    unsigned long long rchar;
    unsigned long long wchar;
    unsigned long long syscr;
    unsigned long long syscw;
    unsigned long long read_bytes;
    unsigned long long write_bytes;
};

SYSCALL_DEFINE2(get_io_throttle, int, pid, struct io_stats_user __user *, udata)
{
    struct task_struct *task;
    struct io_stats_user stats;

    rcu_read_lock();
    task = pid_task(find_vpid(pid), PIDTYPE_PID);
    if (!task) {
        rcu_read_unlock();
        return -ESRCH; 
    }

    // Acceso a las estad铆sticas en task->ioac
    // Estos campos se encuentran en task->ioac.rchar, etc.
    stats.rchar = task->ioac.rchar;
    stats.wchar = task->ioac.wchar;
    stats.syscr = task->ioac.syscr;
    stats.syscw = task->ioac.syscw;
    stats.read_bytes = task->ioac.read_bytes;
    stats.write_bytes = task->ioac.write_bytes;

    rcu_read_unlock();

    if (copy_to_user(udata, &stats, sizeof(stats)))
        return -EFAULT;

    return 0;
}
```
**4. Detalles de las Nuevas Llamadas al Sistema:**  
   - **Estructura general:** Describa el proceso general para agregar una syscall: asignar un n煤mero en `syscall_64.tbl`, definir la funci贸n con `SYSCALL_DEFINE`, e integrar el c贸digo al kernel.  
   - **Syscall `capture_memory_snapshot`:**  
     - **Prop贸sito:** Capturar el estado de la memoria (p谩ginas libres, cache, buffers, etc.)  
     - **Implementaci贸n:** Indique los archivos, funciones internas (`si_meminfo()`, `global_node_page_state()`) y estructuras (`struct mem_snapshot`) utilizadas.  
     - **Ejemplo de uso:** Muestre c贸mo un programa en espacio de usuario llama a esta syscall y qu茅 resultados obtiene.  
   - **Syscall `track_syscall_usage`:**  
     - **Prop贸sito:** Monitorear y contar cu谩ntas veces se ejecutan ciertas syscalls (ej. `read`, `write`).  
     - **Implementaci贸n:** Describa c贸mo se realiz贸 el hooking de `sys_call_table`, las estructuras para almacenar conteos y timestamps, y la syscall que devuelve estos datos.  
     - **Ejemplo de uso:** Presente el c贸digo en espacio de usuario que llama la syscall y muestra los contadores.  
   - **Syscall `get_io_throttle`:**  
     - **Prop贸sito:** Obtener estad铆sticas de I/O de un proceso espec铆fico (bytes le铆dos/escritos, etc.).  
     - **Implementaci贸n:** Explique c贸mo se accedi贸 a `task_struct` y `task->ioac` para obtener estad铆sticas, y c贸mo se devolvieron al usuario en una estructura.  
     - **Ejemplo de uso:** Ejecute el programa de prueba con el PID de un proceso y muestre el resultado.

**5. Pruebas Realizadas:**  
   - **Pruebas de arranque del kernel:** Mencione c贸mo se verific贸 que el kernel arranca correctamente, con el nombre personalizado y los mensajes de inicio presentes en `dmesg`.  
   - **Pruebas de las syscalls:**  
     - Para `capture_memory_snapshot`: Ejecute el programa de prueba y verifique que las estad铆sticas de memoria correspondan a las reportadas por herramientas del sistema (`free`, `/proc/meminfo`).
     - Para `track_syscall_usage`: Ejecute el programa de prueba antes y despu茅s de realizar operaciones de I/O (por ejemplo, usando `cat`, `ls`, etc.) y observe c贸mo los conteos se incrementan.  
     - Para `get_io_throttle`: Seleccione un proceso (por ejemplo, el PID de `bash` o de un programa que lee y escribe archivos), invoque la syscall y verifique que las estad铆sticas correspondan a la carga esperada.  
   - **M贸dulos del kernel:**  
     - Describa las pruebas realizadas con los m贸dulos que muestran estad铆sticas de CPU, memoria y almacenamiento, y c贸mo se verific贸 su correcto funcionamiento (por ejemplo, leyendo las entradas en `/proc` o usando un script de prueba).

**6. Reflexi贸n Personal:**  
A continuaci贸n se presenta una documentaci贸n descriptiva sobre la creaci贸n, implementaci贸n y funcionamiento del m贸dulo `system_stats` que expone estad铆sticas del sistema a trav茅s de una entrada en `/proc`.

---

### MODULE SYSTEM STATS

1. **Elecci贸n del lenguaje y entorno:**  
   Se us贸 el lenguaje C, ya que es el est谩ndar para el desarrollo de m贸dulos del kernel Linux. El m贸dulo se implement贸 sobre un kernel Linux ya configurado y con las cabeceras (`linux-headers`) o el 谩rbol de c贸digo fuente del kernel preparado mediante `make modules_prepare`.

2. **C贸digo Fuente (`system_stats.c`):**  
   El archivo fuente del m贸dulo define las funciones necesarias para:
   - Crear una entrada en `/proc` al cargar el m贸dulo.
   - Obtener estad铆sticas de CPU, memoria y disco utilizando las APIs internas del kernel (ej. `si_meminfo()` para memoria, `vfs_statfs()` para el disco, y `kcpustat_cpu()` para CPU).
   - Implementar la funci贸n `show` que, al leer el archivo en `/proc`, imprime la informaci贸n recolectada.

   Se utilizan las siguientes estructuras y funciones:
   - **Para Memoria:** `si_meminfo()` y `global_node_page_state()` para obtener informaci贸n total y libre.
   - **Para Almacenamiento:** `kern_path()` y `vfs_statfs()` para obtener espacio total y libre de una partici贸n especificada.
   - **Para CPU:** `kcpustat_cpu()` para acceder a los contadores de tiempo de CPU en diversos estados (user, system, idle, etc.).

   En versiones modernas del kernel, en vez de `struct file_operations`, se usa `struct proc_ops` para las operaciones del archivo `/proc`. As铆, el c贸digo adapta su implementaci贸n a esta interfaz.

3. **Makefile y Compilaci贸n:**
   Se cre贸 un `Makefile` simple con aproximadamente este contenido:
   ```make
   obj-m += system_stats.o

   all:
   	make -C /path/to/kernel/source M=$(PWD) modules (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) modules)

   clean:
   	make -C /path/to/kernel/source M=$(PWD) clean (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) clean)
   ```
   
   Aqu铆, `/path/to/kernel/source` es la ruta al 谩rbol de c贸digo fuente del kernel preparado con `make modules_prepare`.  
   Ejecutando `make`, se genera el archivo `system_stats.ko`, listo para ser insertado en el kernel.

4. **Carga del M贸dulo:**
   Una vez compilado, para cargar el m贸dulo se usa:
   ```bash
   sudo insmod system_stats.ko
   ```
   
   Si no hay errores, se crear谩 `/proc/system_stats`.

5. **Verificaci贸n:**
   Se puede verificar su correcto funcionamiento ejecutando:
   ```bash
   cat /proc/system_stats
   ```
   
   Esto mostrar谩 datos como:
   - Estad铆sticas de CPU (tiempos acumulados en distintos estados).
   - Memoria total y libre.
   - Espacio total y libre del almacenamiento en la partici贸n especificada.

   ![alt text](image-1.png)
   
6. **Descarga del M贸dulo:**
   Cuando ya no se necesite el m贸dulo, se descarga con:
   ```bash
   sudo rmmod system_stats
   ```
   
   Esto remover谩 la entrada `/proc/system_stats`.

---

### C贸mo Funciona el M贸dulo Internamente

1. **Creaci贸n de la Entrada en `/proc`:**  
   Al cargar el m贸dulo, la funci贸n `system_stats_init()` llama a `proc_create()` para generar una entrada llamada `system_stats` en `/proc`. Esta funci贸n recibe un `struct proc_ops` con las funciones para gestionar la apertura, lectura, desplazamiento y cierre del archivo virtual. En este caso, se utiliza `single_open()` y `seq_read()` para facilitar la presentaci贸n de datos.

2. **Obtenci贸n de Estad铆sticas:**
   - **Memoria:**  
     Se usa `si_meminfo()` para obtener la informaci贸n global de la memoria (total, libre). Estos valores se imprimen convertidos a kilobytes.
   
   - **Almacenamiento:**  
     A trav茅s de `kern_path()` y `vfs_statfs()` se obtiene la informaci贸n de una partici贸n particular (ej. `/`), mostrando el total de espacio y el espacio libre.
   
   - **CPU:**  
     Se recorren todos los CPUs l贸gicos con `for_each_possible_cpu()` y se suman los contadores obtenidos con `kcpustat_cpu()`. Esto brinda tiempos acumulados en modo usuario, sistema, idle, etc. El m贸dulo muestra estos valores tal cual son, sin convertirlos en porcentajes, pero estos datos pueden servir para c谩lculos posteriores.

3. **Interfaz con Espacio de Usuario:**
   Al ejecutar `cat /proc/system_stats`, el kernel invoca la funci贸n `show` del `seq_file`, la cual llama internamente a las funciones que obtienen las estad铆sticas. Dichas estad铆sticas se formatean en texto y se imprimen en la secuencia (`seq_printf`). El usuario, al leer el archivo, ve estos datos directamente.

---

### Modulos para las syscalls creadas anteriormente

A continuaci贸n se presenta la documentaci贸n que describe el proceso de creaci贸n, instalaci贸n y uso de los m贸dulos del kernel desarrollados para exponer estad铆sticas del sistema y resultados de las syscalls personalizadas.

---

### Introducci贸n

Estos m贸dulos del kernel se crearon con el objetivo de exponer, mediante archivos en `/proc`, informaci贸n que antes se obten铆a a trav茅s de las syscalls personalizadas. De esta manera, los usuarios pueden inspeccionar las estad铆sticas del sistema con simples lecturas (`cat`) a archivos en el sistema de ficheros `procfs`. Cada m贸dulo corresponde a una funcionalidad distinta:

- `capture_mem_mod`: Muestra un snapshot de la memoria.
- `track_syscalls_mod`: Presenta el conteo y 煤ltimos timestamps de ciertas syscalls monitorizadas.
- `io_throttle_mod`: Muestra estad铆sticas de I/O para un proceso espec铆fico.
- `system_stats`: Ofrece estad铆sticas generales de CPU, memoria y almacenamiento.

---

### Creaci贸n de los M贸dulos

1. **C贸digo Fuente y Estructura de Archivos:**  
   Cada m贸dulo se implement贸 en un archivo `.c` separado (por ejemplo, `capture_mem_mod.c`, `track_syscalls_mod.c`, etc.). Estos archivos incluyen:
   - Cabeceras del kernel (`<linux/module.h>`, `<linux/proc_fs.h>`, `<linux/seq_file.h>`, etc.).
   - Funciones `init` y `exit` marcadas con `module_init()` y `module_exit()`.
   - Una funci贸n principal de lectura (`show`) que usa la API de `seq_file` para imprimir las estad铆sticas.
   - Estructuras `proc_ops` para definir c贸mo se lee el archivo `/proc`.

   Por ejemplo, `capture_mem_mod.c` crea `/proc/capture_mem` y al leerlo, muestra el estado actual de la memoria. Esto replica la l贸gica de la syscall `capture_memory_snapshot`, pero ahora como un m贸dulo independiente.

2. **Makefile para Compilaci贸n:**  
   En el directorio donde se encuentra el c贸digo fuente de cada m贸dulo, se crea un `Makefile` simple con contenido similar a:
   ```make
   obj-m += system_stats.o

   all:
   	make -C /path/to/kernel/source M=$(PWD) modules (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) modules)

   clean:
   	make -C /path/to/kernel/source M=$(PWD) clean (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) clean)
   ```
   
   Ajustando el `-C /ruta/al/kernel` si se cuenta con el 谩rbol de c贸digo fuente del kernel en otra ubicaci贸n. Esto utilizar谩 el sistema de build del kernel para compilar el m贸dulo.

3. **Configuraci贸n del Entorno:**  
   Antes de compilar, es necesario tener instaladas las cabeceras del kernel (`linux-headers-<versi贸n>`). Por ejemplo:
   ```bash
   sudo apt-get install linux-headers-$(uname -r)
   ```

   Si se est谩 utilizando un kernel personalizado, se debe contar con el 谩rbol de c贸digo fuente del kernel y haber ejecutado `make modules_prepare` para preparar el entorno antes de compilar m贸dulos externos.

---

### Instalaci贸n de los M贸dulos

1. **Compilaci贸n:**
   Desde el directorio que contiene el c贸digo fuente y el Makefile del m贸dulo, ejecutar:
   ```bash
   make
   ```
   
   Si todo va bien, se generar谩 un archivo `.ko`, por ejemplo `capture_mem_mod.ko`.

2. **Carga del M贸dulo:**
   Para insertar el m贸dulo en el kernel:
   ```bash
   sudo insmod capture_mem_mod.ko
   ```
   
   Si el m贸dulo necesita par谩metros (como en el caso de `io_throttle_mod` que requiere un `pid`), se puede especificar:
   ```bash
   sudo insmod io_throttle_mod.ko pid=1234
   ```

3. **Creaci贸n de la Entrada en /proc:**
   Una vez cargado, el m贸dulo crear谩 un archivo en `/proc` (por ejemplo, `/proc/capture_mem` o `/proc/track_syscalls`). No es necesario ning煤n otro paso, la creaci贸n ocurre autom谩ticamente.

4. **Verificaci贸n de la Funcionalidad:**
   Para leer la informaci贸n expuesta por el m贸dulo:
   ```bash
   cat /proc/capture_mem
   ```
   Mostrar谩 las estad铆sticas correspondientes. Lo mismo para los dem谩s m贸dulos:
   ```bash
   cat /proc/track_syscalls
   cat /proc/io_throttle
   cat /proc/system_stats
   ```
   ![alt text](image-2.png)
   
5. **Descarga del M贸dulo:**
   Si ya no se necesita el m贸dulo en memoria, se descarga con:
   ```bash
   sudo rmmod capture_mem_mod
   ```
   
   Esto remover谩 la entrada `/proc` asociada.

---

### Consideraciones Adicionales

- **Dependencias entre M贸dulos:**
  Si el m贸dulo `track_syscalls_mod` necesita acceso a variables globales definidas en el c贸digo del hooking (donde se interceptaron las syscalls), es necesario exportar esos s铆mbolos con `EXPORT_SYMBOL()` en el m贸dulo (o kernel) que los define. Luego, primero se carga el m贸dulo que exporta las variables y despu茅s el que las utiliza.

- **Permisos y Seguridad:**
  Estos m贸dulos exponen informaci贸n en `/proc` sin ninguna autenticaci贸n. Por defecto, `/proc` es legible por todos, por lo que la informaci贸n quedar谩 accesible a cualquier usuario. Si se requieren restricciones, se pueden ajustar los permisos al crear el archivo `/proc`.

- **Mantenimiento y Limpieza:**
  Despu茅s de probar y validar el funcionamiento, siempre es buena pr谩ctica remover los m贸dulos y limpiar el directorio:
  ```bash
  make clean
  ```
  
  Esto eliminar谩 los archivos generados durante la compilaci贸n.

---

### Conclusi贸n

La creaci贸n e instalaci贸n de estos m贸dulos facilita la visualizaci贸n de estad铆sticas del sistema y la verificaci贸n de las syscalls personalizadas desarrolladas en el proyecto. Con simples lecturas a `/proc`, es posible acceder a datos internos del kernel de manera flexible y transparente. El flujo general es:

1. Escribir el c贸digo fuente del m贸dulo (`.c`), usando `proc_create()` y `seq_file`.
2. Preparar el entorno con cabeceras del kernel.
3. Compilar con `make`.
4. Insertar el m贸dulo (`insmod`) y leer los datos en `/proc`.
5. Cuando ya no se necesite, remover el m贸dulo (`rmmod`) y limpiar (`make clean`).

Esta documentaci贸n provee los fundamentos necesarios para comprender y replicar el proceso en entornos similares.