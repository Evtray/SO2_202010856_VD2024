## Laboratorio Sistemas Operativos 2 ##

### PRACTICA 1 ###

### **Nombre:** Edwin Sandoval Lopez
### **Carne:** 202010856  


**Introducci√≥n y Objetivos del Proyecto:**  
   - **Objetivos generales:** Este proyecto desaf√≠a a los estudiantes a personalizar y expandir el kernel de Linux, permiti√©ndoles
      modificar su comportamiento y agregar nuevas funcionalidades. Involucra la configuraci√≥n de un
      entorno de desarrollo adecuado para la compilaci√≥n del kernel, la implementaci√≥n de cambios
      personalizados en el sistema y el desarrollo de m√≥dulos que a√±aden llamadas al sistema.

   - **Objetivos espec√≠ficos:** 
     - Configurar un entorno de desarrollo para el kernel.  
     - Personalizar el nombre del sistema y agregar mensajes de inicio.  
          - Implementar tres nuevas syscalls personalizadas (`capture_memory_snapshot`, `track_syscall_usage`, `get_io_throttle`).  
     - Desarrollar m√≥dulos para obtener estad√≠sticas del sistema (CPU, memoria, almacenamiento).

Aqu√≠ tienes una versi√≥n mejorada del fragmento en formato **Markdown**, con mejor formato, claridad y orden:

```markdown
# Configuraci√≥n del Entorno

## 1. Descargar y preparar el kernel
1. **Descargar el kernel** desde [kernel.org](https://kernel.org):  
   Archivo recomendado: `linux-6.8.tar.xz`.

2. **Descomprimir el archivo descargado**:
   ```bash
   tar -xvf linux-6.8.tar.xz
   ```

## 2. Instalar las dependencias necesarias
Ejecutar los siguientes comandos para instalar las dependencias del sistema:  
```bash
sudo apt-get install build-essential libncurses5-dev fakeroot wget bzip2 openssl
sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev
```

> **Nota:** Aseg√∫rate de estar en el directorio del c√≥digo fuente del kernel antes de continuar con los siguientes pasos.

---

## 3. Configuraci√≥n inicial del kernel
1. Cambiar a usuario root:
   ```bash
   sudo -s
   ```

2. **Copiar la configuraci√≥n inicial del kernel**:
   ```bash
   cp -v /boot/config-$(uname -r) .config
   ```

3. **Limpiar el ambiente de compilaci√≥n**:
   ```bash
   make clean
   ```

4. **Modificar la versi√≥n del kernel** (opcional):  
   Edita el archivo `Makefile` en la ra√≠z del proyecto. Busca la l√≠nea que contiene `EXTRAVERSION` y modif√≠cala, por ejemplo:
   ```plaintext
   EXTRAVERSION =
   EXTRAVERSION = -49-usac1
   ```

---

## 4. Configuraci√≥n del kernel
1. **Actualizar la configuraci√≥n del kernel**:
   ```bash
   make oldconfig
   ```
   > Presiona **Enter** para aceptar las configuraciones por defecto.

2. **Configurar m√≥dulos locales**:
   ```bash
   make localmodconfig
   ```

3. **Deshabilitar los certificados de firma oficiales de Canonical**:
   ```bash
   scripts/config --disable SYSTEM_TRUSTED_KEYS
   scripts/config --disable SYSTEM_REVOCATION_KEYS
   ```

---

## 5. Compilaci√≥n e instalaci√≥n del kernel
1. Usa el script `compile_and_install.sh` para compilar e instalar el kernel:
   1. Crea el script con tu editor favorito (Nano, Bloc de Notas, etc.).
   2. Asigna permisos de ejecuci√≥n:
      ```bash
      chmod +x compile_and_install.sh
      ```
   3. Ejec√∫talo:
      ```bash
      ./compile_and_install.sh
      ```
   > **Nota:** Durante la ejecuci√≥n, puedes presionar **Enter** para aceptar las configuraciones predeterminadas.

2. Mientras el kernel se compila, puedes **tomarte un caf√©**. ‚òï

3. **Instalar manualmente** (opcional):  
   Si prefieres hacer la instalaci√≥n sin el script, ejecuta los siguientes comandos:
   ```bash
   make modules_install
   make install
   make headers_install
   ```

4. **Acepta las confirmaciones** durante el proceso de instalaci√≥n.

---

¬°Listo! Ahora tu kernel deber√≠a estar compilado e instalado correctamente. üéâ
```

**Descripci√≥n de Modificaciones en el Kernel:**  
   - **Personalizaci√≥n del nombre:** 
      En `/include/linux/uts.h` editar la funci√≤n  start_kernel(), 
      ```c
        #define UTS_SYSNAME "Usac Linux - 202010856"
      ```
   - **Personalizaci√≥n del mensajes de inicio:** 
      En `/init/main.c` editar la funci√≤n  start_kernel(), 
      ```c
          void start_kernel(void)
          {
          //codigo
          	printk("******************************************************\n");
            printk("*                                                    *\n");
            printk("*  Bienvenido al Kernel de Edwin - Versi√≥n 1.0       *\n");
            printk("*  Donde la personalizaci√≥n se encuentra con la      *\n");
            printk("*  potencia del sistema Linux. ¬°A programar! üöÄ      *\n");
            printk("*                                                    *\n");
            printk("******************************************************\n");
          //codigo 
          }
      ```
## Compilar el kernel

``` bash
üí° sudo make -j$(nproc)
```
```bash
$ sudo make modules_install
```

```bash
$ sudo make install
```

```bash
$ sudo reboot
```
## Verificacion de los cambios del Kernel

```bash
$ uname -rs
```

```bash
 $ dmesg | grep "Bienvenido"
 ```
![alt text](image.png)
---
# Llamadas al sistema

Para agregar la syscall `capture_memory_snapshot`, primero se seleccion√≥ un n√∫mero de syscall no utilizado (ej. 462) y se actualiz√≥ el archivo `arch/x86/entry/syscalls/syscall_64.tbl` agregando una l√≠nea como:

```
462    64    capture_memory_snapshot    sys_capture_memory_snapshot
```

Posteriormente, se implement√≥ la funci√≥n `SYSCALL_DEFINE` correspondiente en el c√≥digo del kernel (por ejemplo en `kernel/capture_snapshot.c`).


Para instalar la nueva syscall en el kernel:

1. **Actualizaci√≥n de la Tabla de Syscalls:**  
   Se edit√≥ `syscall_64.tbl` para asignar el n√∫mero de syscall a `capture_memory_snapshot`.

2. **Definici√≥n de la Syscall en el C√≥digo del Kernel:**  
   Se cre√≥ la funci√≥n `SYSCALL_DEFINE` que implementa la l√≥gica de `capture_memory_snapshot`.  
   Retorna 0 en caso de √©xito, o un valor negativo si hay error (por ejemplo, si user_snap apunta a memoria no v√°lida).

3. **Compilaci√≥n e Integraci√≥n con el Kernel:**  
   El archivo `capture_snapshot.c` se incluy√≥ en el `kernel/Makefile` del kernel (ej. `obj-y += capture_snapshot.o`) y se recompil√≥ el kernel. Tras reiniciar con el nuevo kernel, la syscall qued√≥ disponible para su uso en espacio de usuario.


**Implementaci√≥n del Syscall `track_syscall_usage`:**

Para agregar la syscall `track_syscall_usage`, primero se seleccion√≥ un n√∫mero de syscall no utilizado (ej. 463) y se actualiz√≥ el archivo `arch/x86/entry/syscalls/syscall_64.tbl` agregando una l√≠nea como:

```
463    64    track_syscall_usage    sys_track_syscall_usage
```

Posteriormente, se implement√≥ la funci√≥n `SYSCALL_DEFINE` correspondiente en el c√≥digo del kernel (por ejemplo en `kernel/track_usage.c`). Esta funci√≥n recibe un buffer y un tama√±o, y copia al espacio de usuario la informaci√≥n recopilada sobre el uso de las syscalls interceptadas.

Para instalar la nueva syscall en el kernel:

1. **Actualizaci√≥n de la Tabla de Syscalls:**  
   Se edit√≥ `syscall_64.tbl` para asignar el n√∫mero de syscall a `track_syscall_usage`.

2. **Definici√≥n de la Syscall en el C√≥digo del Kernel:**  
   Se cre√≥ la funci√≥n `SYSCALL_DEFINE` que implementa la l√≥gica de `track_syscall_usage`.  
   Esta funci√≥n se encarga de devolver un arreglo de estructuras con informaci√≥n sobre las syscalls monitoreadas (por ejemplo, `open`, `read`, `write`, `fork`): contador de invocaciones y √∫ltimo timestamp.

3. **Compilaci√≥n e Integraci√≥n con el Kernel:**  
   El archivo `track_usage.c` se incluy√≥ en el `kernel/Makefile` del kernel (ej. `obj-y += track_usage.o`) y se recompil√≥ el kernel. Tras reiniciar con el nuevo kernel, la syscall qued√≥ disponible para su uso en espacio de usuario.

Una vez instalada la syscall, un programa en espacio de usuario puede invocarla mediante `syscall(464, info, size)`, obteniendo as√≠ los datos recolectados. Este proceso de agregar la syscall se emplear√° igualmente para los otros dos syscalls personalizados del proyecto, siguiendo el mismo procedimiento: elegir un n√∫mero libre, actualizar `syscall_64.tbl`, implementar la funci√≥n `SYSCALL_DEFINE` con su l√≥gica espec√≠fica, recompilar el kernel e iniciar con √©l.


---

**Secciones del C√≥digo:**
  ```c
  #include <linux/kernel.h>
  #include <linux/syscalls.h>
  #include <linux/timekeeping.h>
  #include <linux/module.h>
  #include <linux/init.h>
  #include <linux/spinlock.h>
  #include <linux/uaccess.h>
  #include <linux/string.h>
  ```

  Estas incluyen las funciones y tipos necesarios para:
  - Definir syscalls.
  - Trabajar con tiempo (nanosegundos).
  - Gestionar sincronizaci√≥n por spinlocks.
  - Acceder a funciones espec√≠ficas del kernel y estructuras b√°sicas.
  
- **Declaraci√≥n de la Tabla de Syscalls:**
  ```c
  extern void* sys_call_table[];
  ```

  Este puntero externo hace referencia a la tabla de llamadas al sistema que se modificar√° para interceptar las syscalls.  
  *(En la implementaci√≥n real, la obtenci√≥n de `sys_call_table` puede requerir t√©cnicas adicionales.)*

- **Definici√≥n de Estructuras:**
  ```c
  struct my_tracked_syscall_info {
      const char *name;               // Nombre simb√≥lico de la syscall
      unsigned long count;            // Conteo de invocaciones
      u64 last_timestamp_ns;          // √öltimo timestamp en nanosegundos
      asmlinkage long (*original)(const struct pt_regs *); // Puntero a la funci√≥n original
  };
  ```

  Esta estructura almacena informaci√≥n acerca de cada syscall monitoreada.

- **Arreglo de Syscalls Monitoreadas:**
  ```c
  static struct my_tracked_syscall_info monitored_syscalls[] = {
      { .name = "open",  .count = 0, .last_timestamp_ns = 0, .original = NULL },
      { .name = "read",  .count = 0, .last_timestamp_ns = 0, .original = NULL },
      { .name = "write", .count = 0, .last_timestamp_ns = 0, .original = NULL },
      { .name = "fork",  .count = 0, .last_timestamp_ns = 0, .original = NULL }
  };
  static int monitored_count = 4;
  ```
  
  Aqu√≠ se listan las syscalls a interceptar. `monitored_count` indica cu√°ntas se est√°n rastreando.

- **Spinlock para Sincronizaci√≥n:**
  ```c
  static DEFINE_SPINLOCK(syscall_usage_lock);
  ```

  Este lock protege el acceso a las estructuras contadoras, evitando condiciones de carrera cuando m√∫ltiples CPUs actualizan las estad√≠sticas simult√°neamente.

- **Wrappers de Syscalls Interceptadas:**
  Cada syscall interceptada tiene un wrapper que:
  1. Obtiene el timestamp actual.
  2. Incrementa el contador y actualiza el timestamp en la estructura correspondiente.
  3. Llama a la funci√≥n original para no alterar el comportamiento del sistema.
  
  Ejemplo para `read`:
  ```c
  static asmlinkage long hooked_read(const struct pt_regs *regs) {
      long ret;
      u64 now = ktime_get_ns();
      unsigned long flags;

      spin_lock_irqsave(&syscall_usage_lock, flags);
      monitored_syscalls[1].count++;
      monitored_syscalls[1].last_timestamp_ns = now;
      spin_unlock_irqrestore(&syscall_usage_lock, flags);

      ret = monitored_syscalls[1].original(regs);
      return ret;
  }
  ```
  
  Se implementan wrappers similares para `open`, `write` y `fork`.

- **Modificaci√≥n de la sys_call_table:**
  Antes de escribir en la `sys_call_table`, se deshabilita la protecci√≥n de s√≥lo lectura, se guardan los punteros originales, se escriben las nuevas direcciones de las funciones wrapper, y luego se restaura la protecci√≥n de la tabla.

  ```c
  // Ejemplo: sys_call_table[__NR_read] = (void*)hooked_read;
  ```

- **Nueva Syscall: `track_syscall_usage`:**
  Esta syscall se define utilizando `SYSCALL_DEFINE`:
  ```c
  struct syscall_usage_user {
      char name[16];
      unsigned long count;
      unsigned long long last_timestamp_ns;
  };

  SYSCALL_DEFINE2(track_syscall_usage, struct syscall_usage_user __user *, buf, int, size) {
      int i;
      unsigned long flags;

      // Verifica que el buffer en el espacio de usuario sea suficiente
      if (size < monitored_count)
          return -EINVAL;

      spin_lock_irqsave(&syscall_usage_lock, flags);
      for (i = 0; i < monitored_count; i++) {
          struct syscall_usage_user temp;
          strncpy(temp.name, monitored_syscalls[i].name, sizeof(temp.name));
          temp.count = monitored_syscalls[i].count;
          temp.last_timestamp_ns = monitored_syscalls[i].last_timestamp_ns;

          if (copy_to_user(&buf[i], &temp, sizeof(temp))) {
              spin_unlock_irqrestore(&syscall_usage_lock, flags);
              return -EFAULT;
          }
      }
      spin_unlock_irqrestore(&syscall_usage_lock, flags);

      return monitored_count;
  }
  ```

---
**Implementaci√≥n del Syscall `get_io_throttle`:**

Para agregar la syscall `capture_memory_snapshot`, primero se seleccion√≥ un n√∫mero de syscall no utilizado (ej. 464) y se actualiz√≥ el archivo `arch/x86/entry/syscalls/syscall_64.tbl` agregando una l√≠nea como:

```
464    64    capture_memory_snapshot    sys_capture_memory_snapshot
```

Posteriormente, se implement√≥ la funci√≥n `SYSCALL_DEFINE` correspondiente en el c√≥digo del kernel (por ejemplo en `kernel/get_io_throttle.c`).


Para instalar la nueva syscall en el kernel:

1. **Actualizaci√≥n de la Tabla de Syscalls:**  
   Se edit√≥ `syscall_64.tbl` para asignar el n√∫mero de syscall a `get_io_throttle`.

2. **Definici√≥n de la Syscall en el C√≥digo del Kernel:**  
   Se cre√≥ la funci√≥n `SYSCALL_DEFINE` que implementa la l√≥gica de `get_io_throttle`.  
   Retorna 0 en caso de √©xito, o un valor negativo si hay error (por ejemplo, si user_snap apunta a memoria no v√°lida).

3. **Compilaci√≥n e Integraci√≥n con el Kernel:**  
   El archivo `get_io_throttle.c` se incluy√≥ en el `kernel/Makefile` del kernel (ej. `obj-y += get_io_throttle.o`) y se recompil√≥ el kernel. Tras reiniciar con el nuevo kernel, la syscall qued√≥ disponible para su uso en espacio de usuario.

```c
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/pid.h>
#include <linux/sched.h>
#include <linux/sched/signal.h>
#include <linux/types.h>

struct io_stats_user {
    unsigned long long rchar;
    unsigned long long wchar;
    unsigned long long syscr;
    unsigned long long syscw;
    unsigned long long read_bytes;
    unsigned long long write_bytes;
};

SYSCALL_DEFINE2(get_io_throttle, int, pid, struct io_stats_user __user *, udata)
{
    struct task_struct *task;
    struct io_stats_user stats;

    rcu_read_lock();
    task = pid_task(find_vpid(pid), PIDTYPE_PID);
    if (!task) {
        rcu_read_unlock();
        return -ESRCH; 
    }

    // Acceso a las estad√≠sticas en task->ioac
    // Estos campos se encuentran en task->ioac.rchar, etc.
    stats.rchar = task->ioac.rchar;
    stats.wchar = task->ioac.wchar;
    stats.syscr = task->ioac.syscr;
    stats.syscw = task->ioac.syscw;
    stats.read_bytes = task->ioac.read_bytes;
    stats.write_bytes = task->ioac.write_bytes;

    rcu_read_unlock();

    if (copy_to_user(udata, &stats, sizeof(stats)))
        return -EFAULT;

    return 0;
}
```
**4. Detalles de las Nuevas Llamadas al Sistema:**  
   - **Estructura general:** Describa el proceso general para agregar una syscall: asignar un n√∫mero en `syscall_64.tbl`, definir la funci√≥n con `SYSCALL_DEFINE`, e integrar el c√≥digo al kernel.  
   - **Syscall `capture_memory_snapshot`:**  
     - **Prop√≥sito:** Capturar el estado de la memoria (p√°ginas libres, cache, buffers, etc.)  
     - **Implementaci√≥n:** Indique los archivos, funciones internas (`si_meminfo()`, `global_node_page_state()`) y estructuras (`struct mem_snapshot`) utilizadas.  
     - **Ejemplo de uso:** Muestre c√≥mo un programa en espacio de usuario llama a esta syscall y qu√© resultados obtiene.  
   - **Syscall `track_syscall_usage`:**  
     - **Prop√≥sito:** Monitorear y contar cu√°ntas veces se ejecutan ciertas syscalls (ej. `read`, `write`).  
     - **Implementaci√≥n:** Describa c√≥mo se realiz√≥ el hooking de `sys_call_table`, las estructuras para almacenar conteos y timestamps, y la syscall que devuelve estos datos.  
     - **Ejemplo de uso:** Presente el c√≥digo en espacio de usuario que llama la syscall y muestra los contadores.  
   - **Syscall `get_io_throttle`:**  
     - **Prop√≥sito:** Obtener estad√≠sticas de I/O de un proceso espec√≠fico (bytes le√≠dos/escritos, etc.).  
     - **Implementaci√≥n:** Explique c√≥mo se accedi√≥ a `task_struct` y `task->ioac` para obtener estad√≠sticas, y c√≥mo se devolvieron al usuario en una estructura.  
     - **Ejemplo de uso:** Ejecute el programa de prueba con el PID de un proceso y muestre el resultado.

**5. Pruebas Realizadas:**  
   - **Pruebas de arranque del kernel:** Mencione c√≥mo se verific√≥ que el kernel arranca correctamente, con el nombre personalizado y los mensajes de inicio presentes en `dmesg`.  
   - **Pruebas de las syscalls:**  
     - Para `capture_memory_snapshot`: Ejecute el programa de prueba y verifique que las estad√≠sticas de memoria correspondan a las reportadas por herramientas del sistema (`free`, `/proc/meminfo`).
     - Para `track_syscall_usage`: Ejecute el programa de prueba antes y despu√©s de realizar operaciones de I/O (por ejemplo, usando `cat`, `ls`, etc.) y observe c√≥mo los conteos se incrementan.  
     - Para `get_io_throttle`: Seleccione un proceso (por ejemplo, el PID de `bash` o de un programa que lee y escribe archivos), invoque la syscall y verifique que las estad√≠sticas correspondan a la carga esperada.  
   - **M√≥dulos del kernel:**  
     - Describa las pruebas realizadas con los m√≥dulos que muestran estad√≠sticas de CPU, memoria y almacenamiento, y c√≥mo se verific√≥ su correcto funcionamiento (por ejemplo, leyendo las entradas en `/proc` o usando un script de prueba).

**6. Reflexi√≥n Personal:**  
A continuaci√≥n se presenta una documentaci√≥n descriptiva sobre la creaci√≥n, implementaci√≥n y funcionamiento del m√≥dulo `system_stats` que expone estad√≠sticas del sistema a trav√©s de una entrada en `/proc`.

---

### MODULE SYSTEM STATS

1. **Elecci√≥n del lenguaje y entorno:**  
   Se us√≥ el lenguaje C, ya que es el est√°ndar para el desarrollo de m√≥dulos del kernel Linux. El m√≥dulo se implement√≥ sobre un kernel Linux ya configurado y con las cabeceras (`linux-headers`) o el √°rbol de c√≥digo fuente del kernel preparado mediante `make modules_prepare`.

2. **C√≥digo Fuente (`system_stats.c`):**  
   El archivo fuente del m√≥dulo define las funciones necesarias para:
   - Crear una entrada en `/proc` al cargar el m√≥dulo.
   - Obtener estad√≠sticas de CPU, memoria y disco utilizando las APIs internas del kernel (ej. `si_meminfo()` para memoria, `vfs_statfs()` para el disco, y `kcpustat_cpu()` para CPU).
   - Implementar la funci√≥n `show` que, al leer el archivo en `/proc`, imprime la informaci√≥n recolectada.

   Se utilizan las siguientes estructuras y funciones:
   - **Para Memoria:** `si_meminfo()` y `global_node_page_state()` para obtener informaci√≥n total y libre.
   - **Para Almacenamiento:** `kern_path()` y `vfs_statfs()` para obtener espacio total y libre de una partici√≥n especificada.
   - **Para CPU:** `kcpustat_cpu()` para acceder a los contadores de tiempo de CPU en diversos estados (user, system, idle, etc.).

   En versiones modernas del kernel, en vez de `struct file_operations`, se usa `struct proc_ops` para las operaciones del archivo `/proc`. As√≠, el c√≥digo adapta su implementaci√≥n a esta interfaz.

3. **Makefile y Compilaci√≥n:**
   Se cre√≥ un `Makefile` simple con aproximadamente este contenido:
   ```make
   obj-m += system_stats.o

   all:
   	make -C /path/to/kernel/source M=$(PWD) modules (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) modules)

   clean:
   	make -C /path/to/kernel/source M=$(PWD) clean (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) clean)
   ```
   
   Aqu√≠, `/path/to/kernel/source` es la ruta al √°rbol de c√≥digo fuente del kernel preparado con `make modules_prepare`.  
   Ejecutando `make`, se genera el archivo `system_stats.ko`, listo para ser insertado en el kernel.

4. **Carga del M√≥dulo:**
   Una vez compilado, para cargar el m√≥dulo se usa:
   ```bash
   sudo insmod system_stats.ko
   ```
   
   Si no hay errores, se crear√° `/proc/system_stats`.

5. **Verificaci√≥n:**
   Se puede verificar su correcto funcionamiento ejecutando:
   ```bash
   cat /proc/system_stats
   ```
   
   Esto mostrar√° datos como:
   - Estad√≠sticas de CPU (tiempos acumulados en distintos estados).
   - Memoria total y libre.
   - Espacio total y libre del almacenamiento en la partici√≥n especificada.

   ![alt text](image-1.png)
   
6. **Descarga del M√≥dulo:**
   Cuando ya no se necesite el m√≥dulo, se descarga con:
   ```bash
   sudo rmmod system_stats
   ```
   
   Esto remover√° la entrada `/proc/system_stats`.

---

### C√≥mo Funciona el M√≥dulo Internamente

1. **Creaci√≥n de la Entrada en `/proc`:**  
   Al cargar el m√≥dulo, la funci√≥n `system_stats_init()` llama a `proc_create()` para generar una entrada llamada `system_stats` en `/proc`. Esta funci√≥n recibe un `struct proc_ops` con las funciones para gestionar la apertura, lectura, desplazamiento y cierre del archivo virtual. En este caso, se utiliza `single_open()` y `seq_read()` para facilitar la presentaci√≥n de datos.

2. **Obtenci√≥n de Estad√≠sticas:**
   - **Memoria:**  
     Se usa `si_meminfo()` para obtener la informaci√≥n global de la memoria (total, libre). Estos valores se imprimen convertidos a kilobytes.
   
   - **Almacenamiento:**  
     A trav√©s de `kern_path()` y `vfs_statfs()` se obtiene la informaci√≥n de una partici√≥n particular (ej. `/`), mostrando el total de espacio y el espacio libre.
   
   - **CPU:**  
     Se recorren todos los CPUs l√≥gicos con `for_each_possible_cpu()` y se suman los contadores obtenidos con `kcpustat_cpu()`. Esto brinda tiempos acumulados en modo usuario, sistema, idle, etc. El m√≥dulo muestra estos valores tal cual son, sin convertirlos en porcentajes, pero estos datos pueden servir para c√°lculos posteriores.

3. **Interfaz con Espacio de Usuario:**
   Al ejecutar `cat /proc/system_stats`, el kernel invoca la funci√≥n `show` del `seq_file`, la cual llama internamente a las funciones que obtienen las estad√≠sticas. Dichas estad√≠sticas se formatean en texto y se imprimen en la secuencia (`seq_printf`). El usuario, al leer el archivo, ve estos datos directamente.

---

### Modulos para las syscalls creadas anteriormente

A continuaci√≥n se presenta la documentaci√≥n que describe el proceso de creaci√≥n, instalaci√≥n y uso de los m√≥dulos del kernel desarrollados para exponer estad√≠sticas del sistema y resultados de las syscalls personalizadas.

---

### Introducci√≥n

Estos m√≥dulos del kernel se crearon con el objetivo de exponer, mediante archivos en `/proc`, informaci√≥n que antes se obten√≠a a trav√©s de las syscalls personalizadas. De esta manera, los usuarios pueden inspeccionar las estad√≠sticas del sistema con simples lecturas (`cat`) a archivos en el sistema de ficheros `procfs`. Cada m√≥dulo corresponde a una funcionalidad distinta:

- `capture_mem_mod`: Muestra un snapshot de la memoria.
- `track_syscalls_mod`: Presenta el conteo y √∫ltimos timestamps de ciertas syscalls monitorizadas.
- `io_throttle_mod`: Muestra estad√≠sticas de I/O para un proceso espec√≠fico.
- `system_stats`: Ofrece estad√≠sticas generales de CPU, memoria y almacenamiento.

---

### Creaci√≥n de los M√≥dulos

1. **C√≥digo Fuente y Estructura de Archivos:**  
   Cada m√≥dulo se implement√≥ en un archivo `.c` separado (por ejemplo, `capture_mem_mod.c`, `track_syscalls_mod.c`, etc.). Estos archivos incluyen:
   - Cabeceras del kernel (`<linux/module.h>`, `<linux/proc_fs.h>`, `<linux/seq_file.h>`, etc.).
   - Funciones `init` y `exit` marcadas con `module_init()` y `module_exit()`.
   - Una funci√≥n principal de lectura (`show`) que usa la API de `seq_file` para imprimir las estad√≠sticas.
   - Estructuras `proc_ops` para definir c√≥mo se lee el archivo `/proc`.

   Por ejemplo, `capture_mem_mod.c` crea `/proc/capture_mem` y al leerlo, muestra el estado actual de la memoria. Esto replica la l√≥gica de la syscall `capture_memory_snapshot`, pero ahora como un m√≥dulo independiente.

2. **Makefile para Compilaci√≥n:**  
   En el directorio donde se encuentra el c√≥digo fuente de cada m√≥dulo, se crea un `Makefile` simple con contenido similar a:
   ```make
   obj-m += system_stats.o

   all:
   	make -C /path/to/kernel/source M=$(PWD) modules (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) modules)

   clean:
   	make -C /path/to/kernel/source M=$(PWD) clean (ejm: make -C /home/evtray/Escritorio/linux-6.8 M=$(PWD) clean)
   ```
   
   Ajustando el `-C /ruta/al/kernel` si se cuenta con el √°rbol de c√≥digo fuente del kernel en otra ubicaci√≥n. Esto utilizar√° el sistema de build del kernel para compilar el m√≥dulo.

3. **Configuraci√≥n del Entorno:**  
   Antes de compilar, es necesario tener instaladas las cabeceras del kernel (`linux-headers-<versi√≥n>`). Por ejemplo:
   ```bash
   sudo apt-get install linux-headers-$(uname -r)
   ```

   Si se est√° utilizando un kernel personalizado, se debe contar con el √°rbol de c√≥digo fuente del kernel y haber ejecutado `make modules_prepare` para preparar el entorno antes de compilar m√≥dulos externos.

---

### Instalaci√≥n de los M√≥dulos

1. **Compilaci√≥n:**
   Desde el directorio que contiene el c√≥digo fuente y el Makefile del m√≥dulo, ejecutar:
   ```bash
   make
   ```
   
   Si todo va bien, se generar√° un archivo `.ko`, por ejemplo `capture_mem_mod.ko`.

2. **Carga del M√≥dulo:**
   Para insertar el m√≥dulo en el kernel:
   ```bash
   sudo insmod capture_mem_mod.ko
   ```
   
   Si el m√≥dulo necesita par√°metros (como en el caso de `io_throttle_mod` que requiere un `pid`), se puede especificar:
   ```bash
   sudo insmod io_throttle_mod.ko pid=1234
   ```

3. **Creaci√≥n de la Entrada en /proc:**
   Una vez cargado, el m√≥dulo crear√° un archivo en `/proc` (por ejemplo, `/proc/capture_mem` o `/proc/track_syscalls`). No es necesario ning√∫n otro paso, la creaci√≥n ocurre autom√°ticamente.

4. **Verificaci√≥n de la Funcionalidad:**
   Para leer la informaci√≥n expuesta por el m√≥dulo:
   ```bash
   cat /proc/capture_mem
   ```
   Mostrar√° las estad√≠sticas correspondientes. Lo mismo para los dem√°s m√≥dulos:
   ```bash
   cat /proc/track_syscalls
   cat /proc/io_throttle
   cat /proc/system_stats
   ```
   ![alt text](image-2.png)
   
5. **Descarga del M√≥dulo:**
   Si ya no se necesita el m√≥dulo en memoria, se descarga con:
   ```bash
   sudo rmmod capture_mem_mod
   ```
   
   Esto remover√° la entrada `/proc` asociada.

---

### Consideraciones Adicionales

- **Dependencias entre M√≥dulos:**
  Si el m√≥dulo `track_syscalls_mod` necesita acceso a variables globales definidas en el c√≥digo del hooking (donde se interceptaron las syscalls), es necesario exportar esos s√≠mbolos con `EXPORT_SYMBOL()` en el m√≥dulo (o kernel) que los define. Luego, primero se carga el m√≥dulo que exporta las variables y despu√©s el que las utiliza.

- **Permisos y Seguridad:**
  Estos m√≥dulos exponen informaci√≥n en `/proc` sin ninguna autenticaci√≥n. Por defecto, `/proc` es legible por todos, por lo que la informaci√≥n quedar√° accesible a cualquier usuario. Si se requieren restricciones, se pueden ajustar los permisos al crear el archivo `/proc`.

- **Mantenimiento y Limpieza:**
  Despu√©s de probar y validar el funcionamiento, siempre es buena pr√°ctica remover los m√≥dulos y limpiar el directorio:
  ```bash
  make clean
  ```
  
  Esto eliminar√° los archivos generados durante la compilaci√≥n.

---

### Conclusi√≥n

La creaci√≥n e instalaci√≥n de estos m√≥dulos facilita la visualizaci√≥n de estad√≠sticas del sistema y la verificaci√≥n de las syscalls personalizadas desarrolladas en el proyecto. Con simples lecturas a `/proc`, es posible acceder a datos internos del kernel de manera flexible y transparente. El flujo general es:

1. Escribir el c√≥digo fuente del m√≥dulo (`.c`), usando `proc_create()` y `seq_file`.
2. Preparar el entorno con cabeceras del kernel.
3. Compilar con `make`.
4. Insertar el m√≥dulo (`insmod`) y leer los datos en `/proc`.
5. Cuando ya no se necesite, remover el m√≥dulo (`rmmod`) y limpiar (`make clean`).

Esta documentaci√≥n provee los fundamentos necesarios para comprender y replicar el proceso en entornos similares.